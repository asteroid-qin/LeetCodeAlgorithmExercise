//#include<iostream>
//#include<vector>
//#include<algorithm>
//#include<unordered_map>
//using namespace std;
//
//class Solution {
//public:
//    // 目标：建议直接看官方描述...
//    // 这里只能简单描述：就是g和s中有很多数字，数字相同就可以配对，求最大配对数
//    // 注意！s中大的值可以向下兼容g中小的值！
//    // 思路：把s转成map，key是尺寸，value是数量。用一个变量记录匹配对数
//    // 遍历这个g，当前的值去s中查，如果查到了就--，匹配对数+1
//    // 如果没有查到当前尺寸，就去找更大的尺寸。
//    // 找到了更大尺寸，数量--，匹配对数+1。如果依然找不到就进入下一层循环
//    // 很明显，这个思路是可行的。但是太麻烦了，并且map并不适合遍历找更大值
//    // 所以上面的思路可以改进一下，不使用map，直接对s排序，对g中的值使用二分查找，往s中寻找最大值
//    // 匹配成功就把尺寸的值设置为-1（让下一轮无法匹配），再把这个值移动到最后一位
//    // 然后继续遍历这个g（不过看题目，这个s的长度好像有点高，这么玩的效率依旧很糟糕！！）
//    // 最终升级！直接自己写一个数据结构，使用map+vector，map依旧是key放着尺寸，value是数量
//    // 放入的key按照从大到小排序，这样取得是否看看能不能取到，不能取到就二分法取较大值
//    // 是在取不到就进入下一轮循环，取得到value-1并且匹配对数+1
//    // 最后看官方解析：两个都进行排序，然后根据题意要满足更多的小孩，也就是饼干能够满足大的就满足大的
//    // 所以可以
//    int findContentChildren(vector<int>& g, vector<int>& s) {
//        sort(g.begin(), g.end());
//        sort(s.begin(), s.end());
//
//        int count = 0;
//        // 使用双指针遍历s和g.从低往高匹配
//        for (int i = 0, j = 0; i < g.size() && j < s.size();i++,j++) {
//            // 核心！！
//            // 要满足更多的小孩，其实就是需要使用最小的饼干尺寸去匹配小孩
//            // 使用这个while循环就可以得到能够匹配小孩的最小尺寸
//            while (j < s.size() && g[i] > s[j]) {
//                j++;
//            }
//            // for循环结束有两种可能，一种就是j超出s的长度了，也就是没有找到能够匹配的饼干
//            // 一种就是找到最小尺寸的饼干，可以进入下一轮循环
//            if (j < s.size()) {
//                count++;
//            }
//        }
//         
//        return count;
//    }
//
//    int findContentChildrenP(vector<int>& g, vector<int>& s) {
//        unordered_map<int, int> myMap;
//
//        // 转换
//        for (auto i : s) {
//            myMap[i]++;
//        }
//
//        // 遍历map中的key，把key放入v中并排序
//
//        // 遍历g
//        for (auto i : g) {
//            // 去map中查，查到就返回
//            // 没查到二分法取v中找
//            // 找到就返回
//            // 没找到就算了
//        }
//
//    }
//};
//
//int main(){
//	return 0;
//}