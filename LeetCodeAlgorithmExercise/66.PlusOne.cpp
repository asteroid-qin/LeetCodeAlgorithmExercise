//#include<iostream>
//#include<vector>
//#include<stack>
//using namespace std;
//
//class Solution {
//public:
//    // 根据题意，大概要求：给定一个数，这个数是从高位到低位每位每位的分割并放在vector容器中
//    // 这个方法需要做的就是：把这个数转成一个真正的数然后加一，最后转成对应的vector（只要再遍历一次赋值即可）
//    // 其实很好奇是自己新建一个vector容器还是修改原来的vector容器并返回
//    // 思考一下解题思路：最关键的问题是数有可能往前进一位，比如9->10
//    // 所以可以判断最后一位数是否为9，如果是需要往前进一位，并设置当前数为0，但是这样有一个严重的问题，
//    // 因为有可能出现9999这样的情况，所以不能简单粗暴的判断最后一位，需要循环从后往前判断，并且不能单纯判断
//    // 当前的位数是否为9，应该是判断当前的数加上进位数是否大于十，只有这样才需要往前进位，当前数也只要对10取余即可
//    // 所以整道题应该是从后往前遍历，先得到当前值加上进位数的值now，把当前值设置为sum%10
//    // （这道题其实只判断是否大于10，那就设置为0就好，不然设置为当前数即可）
//    // 然后把now/10的结果赋值给进位数即可，如果大于10那进位数肯定是1不然就是0，如此反复
//    // 当时还有一些问题需要处理！比如当99的情况，按照上面的代码运行则是00，需要在前面补一个1
//    // 问题是何时才需要往前补上1？很明显需要看进位数，如果都遍历完了，进位数依然等于1，说明此时仍然需要往前进一位
//    // 所以只要遍历完vector容器后，判断一下进位数的值即可(OK,一次通过)
//    vector<int> plusOne(vector<int>& digits) {
//        // 拿到这个容器的长度
//        int length = digits.size();
//
//        // 记录进位数(初始值为1，因为按照题意需要加1)
//        int carry = 1;
//
//        // 准备一个栈记录数字
//        stack<int> myStack;
//
//        // 从后往前遍历这个vector
//        for (int i = length - 1; i >= 0; i--) {
//            // 判断当前的值是否大于等于10（按照题意顶多等于10）
//            if (digits[i] + carry == 10) {
//                // 如果等于0了，那当前值肯定为0，并且需要往前进一位
//                myStack.push(0);
//                carry = 1;
//            }
//            else {
//                // 如果不等于10，那就代表没有进位
//                myStack.push(digits[i] + carry);
//                carry = 0;
//            }
//        }
//
//        // 判断进位数的值
//        if (carry == 1) {
//            // 需要往栈中放个1
//            myStack.push(1);
//        }
//
//        // 新建一个vector，把stack中的值放入vector容器中
//        vector<int> v;
//
//        while(!myStack.empty()) {
//            v.push_back(myStack.top());
//            myStack.pop();
//        }
//
//        return v;
//    }
//};
//
//
//int main() {
//    // 开始测试
//    Solution s;
//
//    // 创造一个容器
//    vector<int> v = {0,9,9,9,9};
//
//    vector<int> myv = s.plusOne(v);
//
//    // 打印这个容器
//    for (int i = 0; i < myv.size(); i++) {
//        cout << myv[i];
//    }
//    cout << endl;
//
//    // 暂停
//    system("pause");
//
//	return 0;
//}