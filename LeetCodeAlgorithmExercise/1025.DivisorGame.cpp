//#include<iostream>
//#include<vector>
//using namespace std;
//
//class Solution {
//public:
//    // 目标：我方先手，找出一个在0到N以内（不包括）的数x,使得N%x==0，最后再把N变成N-x，找不到就算失败。
//    // 输入一个数字，如果每个人都是最优处理，判断我方是否会输..
//    // 思路：寻找规律:
//    // 1，0到1内没有整数，直接false
//    // 2，【1】，2%1=1，直接false
//    // 3，【1,2】，直接false
//    // 4，【1,2,3】，选择2，对方变成2直接false，我方true
//    // 5，【1,2,3,4】，直接false
//    // 6，【1,2,3,4,5】，选择2或者3，选择2结果变成4，那对方肯定true，选择3结果变成3，那对面肯定false
//    // 7，直接false
//    // 8，【1-7】，选择2或者4，选2变成6，对面优先出手自己肯定false，选择4变成4，对面优先出手自己肯定false
//    // ...
//    // 根据上面的例子很明显就是找质数。当N等于质数时必false。最后总结：
//    // 创建一个长度为N的数组，从1遍历到N，每到一个数就尝试寻找他的因子
//    // 如果没有因子就false，如果有一因子，判断一个因子满足N-因子==false，如果存在当前为true，直到N
//    // 看完题解后回来了，妈的，绝了！
//    bool divisorGame(int N) {
//        vector<bool> m(N + 1, false); //浪费一个位置但是理解起来会轻松不少...
//
//        for (int i = 2; i <= N; i++) { // 从2开始
//            if (!m[i - 1]) {
//                // 取1的特殊情况..这一步是快写完后加的，刚写下来就突然发现不对劲，最后人傻了...
//                m[i] = true;
//                continue;
//            }
//
//            // 所以下面这个for循环没有任何意义..
//            for (int j = 2; j <= sqrt(i); j++) { // 直接从2开始，因为取不到本身
//                if (i % j == 0) { // j和i/j是因子 
//                    if (!m[i - j] || !m[i - i / j]) { // 只要其中一个导致false，那么当前就是true
//                        m[i] = true;
//                        break;
//                    }
//                }
//            }
//        }
//
//        return m[N];
//    }
//};
//
//int main() {
//	return 0;
//}