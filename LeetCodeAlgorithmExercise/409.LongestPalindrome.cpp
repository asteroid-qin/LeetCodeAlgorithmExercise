//#include<iostream>
//#include<vector>
//using namespace std;
//
//class Solution {
//public:
//    // 目标：给定一个只包含大小写字母的字符串，判断它最高能够构成多少个回文
//    // 思路：可以把这个问题转换成一个字符出现多少次，把他们出现的次数除2再乘2最后加起来，于是得到结果
//    // 注意！这里需要判断是否出现奇数，如果是，需要把结果再+1
//    // OK！虽然两个都是百分百，但是可以写的再优雅点
//    // 新思路：能构成多长的回文，只要求出这个字母-1或者-0变成偶数，这个的字母有多少个，最后
//    // 把总长度减去这个字母的个数就得到全是偶数的长度，也就是构成回文的长度
//    // 如果这样字母的个数等于0，就代表这个字符串可以构成长度不变的回文，不然就是总长度-这样字母的个数+1
//    // （只要有一个字母出现的次数为奇数，那么就可以把这个字母移动到中间，将最终结果+1）
//    int longestPalindrome(string s) {
//        // 因为包含大小写字母，所以需要准备两张不同的表
//        int lowerMap[26] = {0};
//        int upperMap[26] = {0};
//
//        // 判断有多少个奇数
//        int count = 0;
//
//        // 把这个字符串计算得到两张表
//        for (auto c : s) {
//            if (c > 'Z') {
//                // 小写
//                lowerMap[c - 'a']++;
//            }
//            else {
//                upperMap[c - 'A']++;
//            }
//        }
//
//        // 遍历这两张表把值除2再乘2取出
//        for (int i = 0; i < 26; i++) {
//            // 判断当前数是否奇数
//            count += lowerMap[i] % 2 + upperMap[i] % 2;
//        }
//
//        // 如果结果count==0，就代表全是偶数
//        // 不然就返回总大小-奇数个数
//        return count==0?s.size():s.size() - count + 1;
//    }
//};
//
//int main() {
//	return 0;
//}