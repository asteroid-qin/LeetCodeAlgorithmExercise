//#include<iostream>
//#include<vector>
//using namespace std;
//
//class Solution {
//public:
//    // 根据题意，是需要把两个排序vector进行合并并放到第一个容器中，第一个容器容量足够
//    // 思路：既然两个都是已经排序好的，那么就用两个变量使用while循环遍历，判断变量指向的数谁小，小就放到nums中
//    // ，并让小的变量单独自增。while循环结束后
//    // ，有可能第一个全放进去了，也有可能第二个全放进去了，需要两个while把剩下的放入
//    // 三个while结束，问题就解决了。但是还有一个非常关键的问题：
//    // 是自己新建一个容器还是直接修改第一个容器，为了空间复杂度，很明显这里需要想办法不创建容器，直接对第一个容器进行修改
//    // 很明显，从前往后遍历需要用一个容器记录第一个容器中小于第二个容器的数，这样根据数字的不同，最糟糕可能需要产生一个m长度的容器
//    // 所以这题需要从后往前遍历！
//    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
//        // 准备两个变量用于记录第一个容器和第二个容器
//        int i = m - 1, j = n - 1;
//
//        // 用一个变量记录第一个容器里最后的数
//        int k = m + n - 1;
//
//        // 两个容器任何一个到极限了都需要退出循环
//        while (i != -1 && j != -1) {
//            //// 判断变量指向值的大小
//            //if (nums1[i] > nums2[j]) {
//            //    // 如果第一个容器里面的值比第二个里面的要大，把第一个容器里面的值放入
//            //    nums1[k--] = nums1[i--];
//            //}
//            //else {
//            //    // 其他情况就是把j里面的值放进去
//            //    nums1[k--] = nums2[j--];
//            //}
//            // 上面的代码可以优化成一行
//            nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
//        }
//
//        // 继续两个while把剩下的全放进去
//        while (i != -1) {
//            nums1[k--] = nums1[i--];
//        }
//        while (j != -1) {
//            nums1[k--] = nums2[j--];
//        }
//
//        // 三个while结束收工
//    }
//};
//
//// 这里就不需要测试了
//int main() {
//
//
//	return 0;
//}