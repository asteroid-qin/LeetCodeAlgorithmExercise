//#include<iostream>
//#include<vector>
//using namespace std;
//
//class Solution {
//public:
//    // 目标：根据moves找出井字棋的获胜者
//    // 思路：先执行偶数步，每三个判断是否斜率相等，相等时退出并记录当前步
//    // 再执行奇数步，每三个判断斜率，相等时退出并记录当前步
//    // 如果偶数=奇数=-1，就代表平局。否则返回最小值，最小值是偶数就是A获胜否则就是B获胜
//    // 脑阔痛，上面的思路固然可行，但是时间复杂度还是太高了。
//    // 看了一下题解，发现有更好的答案：
//    // 获胜只有八中可能，分别是三行、三列、主对角线、副对角线
//    // 可以用数组来保持这八中可能，根据题意，只要这八中其中有一个值等于3，那么就代表获胜
//    // 再根据题意，一方获胜或者放满就直接停止。所以可以从最后一个元素向前遍历。
//    // 因为最后一个元素要么是获胜者，要么就是放满了，要么是还可以接着放
//    // 综上：倒序遍历moves，i每次+2，用数组记录八种可能，只要其中有一个值等于3就返回这个i（i是偶数就是A否则就是B）
//    // 如果遍历结束依然没有return，就代表要么是放满了，要么可以接着放（此时只要判断moves的大小即可）
//    string tictactoe(vector<vector<int>>& moves) {
//        int arr[8] = { 0 };
//        int m = moves.size();
//        for (int i = m - 1; i >= 0; i -= 2) {
//            arr[moves[i][0]]++; // 行
//            arr[moves[i][1] + 3]++; // 列
//            if (moves[i][0] == moves[i][1]) { // 对正对角线
//                arr[6]++;
//            }
//            if (moves[i][0] + moves[i][1] == 2)// 副对角线
//                arr[7]++;
//
//            if (arr[moves[i][0]] == 3 || arr[moves[i][1] + 3] == 3 || arr[6] == 3 || arr[7] == 3) {
//                return (i % 2 == 0) ? "A" : "B";
//            }
//        }
//
//        if (m < 9) {
//            return "Pending";
//        }
//
//        return "Draw";
//    }
//};
//
//int main() {
//	return 0;
//}